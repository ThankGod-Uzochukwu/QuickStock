QuickStock started with a clear goal: let small retailers capture and review inventory quickly on mobile. I chose Expo so I could iterate fast across iOS and Android, and TypeScript to keep product data consistent. I mapped the core flow: add a product, view it in a compact grid, open details, edit or delete, and persist changes. That flow guided the folder structure and the screen hierarchy.

I set up Expo Router to mirror navigation in the app folder, keeping the main list in the tabs index and modal screens for add and edit. The root layout wires providers so every screen can access the store and theme. I organized UI helpers in components and kept shared design values in styles and constants to make spacing, colors, and typography consistent. This let me tune the look once and reuse it everywhere.

For data, I defined a Product type with id, name, price, image, and timestamps. Business rules live in the product service, which validates names, prices, and image URIs, and creates ids. The Redux slice is the single source of truth for product state, with reducers for add, update, remove, and hydrate. Selectors compute derived values like product counts and remaining slots, keeping calculations out of the UI.

The actions layer connects the UI to side effects. When a user adds a product, the action validates the inputs, updates state, persists to storage, and can trigger notifications when the limit is reached. Updates and deletes follow the same pattern, keeping logic centralized and predictable. The storage adapter wraps persistence so I can swap implementations later without touching screens.

Image handling is isolated in an image service. It requests permissions, opens the device library, and optimizes images with resizing and compression before saving the URI. This keeps thumbnails light, protects performance, and avoids memory issues on older devices. The add form uses this service and shows progress and error states.

The list UI is built with a FlatList grid so users can see more items at once. Each card shows the image, name, and price, plus edit and delete icon buttons. Tapping a card opens a details view with a larger image, summary row, and action buttons, matching the product focus screen. The empty state appears inside the list so the layout stays consistent even when there are no items.

The add and edit flows share the same form component. I made the form accept initial values and custom labels so it works for both create and update. Validation happens before submission, and the submit button disables when required fields are missing. This reduces errors and keeps user feedback immediate.
