I began by clarifying the problem QuickStock solves: fast inventory capture for small retailers who need to scan, store, and review stock on mobile devices. That goal informed every early decision, from choosing Expo for rapid iteration to selecting TypeScript to keep data shapes consistent across screens. I sketched user flows for adding products, viewing lists, and handling empty states, then mapped those flows to a simple feature slice inside features/products. With those flows defined, I set up Redux Toolkit to centralize inventory state and ensure predictable updates. The store wiring in store provides hooks for typed dispatch and selection.

For UI, I leaned on Expo Router to keep navigation declarative and to mirror the folder structure in app/(tabs). I created a root layout for shared providers and a tab layout for the primary list view, ensuring that modals like the add product form could be presented cleanly. To keep styling consistent, I defined design tokens in styles and aligned them with the theme in constants/theme. Reusable components like ThemedText and ThemedView abstracted color mode details so feature components could stay focused on data and layout. This kept screens simple and reduced repetition across the app during early iteration cycles.

Data modeling started with a clear Product interface in features/products/types, covering id, name, quantity, and optional image metadata. I added actions and a slice using Redux Toolkit, choosing normalized arrays to keep the list order intuitive for users. Selectors in products.selectors.ts expose derived data like total items and empty state checks, keeping calculations out of components. Service helpers in product.service.ts handle id generation and basic validation, while storage adapters encapsulate persistence concerns. This separation made testing straightforward and reduced coupling between UI and state updates. It also enabled future sync features without changing the list components or store wiring later.

For persistence, I created a storage adapter in services/storage that hides the underlying API and can be swapped later. The persistence service exposes async get and set functions, and the products slice can call thunks that hydrate the store on launch. I kept the initial load lightweight by reading once and caching in state, avoiding redundant disk access during list rendering. For image handling, I added an image service wrapper to centralize any future transformations or compression. This ensures the UI stays responsive while keeping business rules in one place. Those abstractions also simplified mocking in tests and data setups.

On the UI side, I built ProductCard to display the key fields with clear hierarchy and spacing. The card uses theme colors and a subtle container background from design tokens, making it readable in light and dark modes. ProductList wraps FlatList and handles separators, empty states, and pull to refresh hooks for future extensions. EmptyState is intentionally cheerful, encouraging users to add their first item while keeping the screen uncluttered. I used small helper components like HapticTab to provide feedback without requiring custom native modules. This balance kept the interface polished while preserving the agility of Expo for early demos.

For the add product flow, I designed AddProductForm with clear labels, validation hints, and a predictable submit path. Fields are controlled inputs, and the handler assembles a product object before dispatching the create action. I placed the form in a modal screen so the list context remains visible and users can quickly return. Error messaging is minimal but actionable, and the submit button disables when required fields are missing. I also wired in image selection hooks for future enhancement, but kept the logic optional to avoid friction. This keeps onboarding simple while leaving room for richer capture as needs grow.

Navigation and state providers are composed in the root layout, where I wrapped the app with the Redux Provider and theme context. This ensures every screen can access hooks without prop drilling, and it keeps platform specific behaviors centralized. I included small utilities like useColorScheme and useThemeColor to abstract platform differences and simplify styling decisions. Where possible, I relied on components from the templates folder to keep design language consistent with Expo defaults. This reduced cognitive load and allowed me to focus on product features rather than reinventing foundational UI. It also aligns with maintainability goals for future contributors overall.

I emphasized accessibility by keeping font sizes readable, ensuring sufficient color contrast, and using clear touch targets. ThemedText supports dynamic color selection, and I avoided hard coded colors in feature components to prevent inconsistencies. I also structured layout with spacing tokens and consistent padding, which keeps the list scannable and tap friendly. When designing empty states, I provided friendly language and subtle motion to reassure users the app is working. Haptic feedback reinforces actions without forcing sound, making the experience pleasant in quiet environments. These details improve trust and encourage regular inventory updates for teams and solo operators every day.

Quality control came from incremental testing during development, especially around reducers and selectors where logic errors can hide. I used mock data sets to verify list rendering, empty views, and edge cases like duplicate names or zero quantity entries. Linting and TypeScript checks helped keep the codebase predictable, and I favored small functions that are easy to reason about. Whenever I introduced a new component, I checked it on both iOS and Android simulators to confirm parity. This habit surfaced layout differences early and prevented regression later. I documented decisions in code comments where intent was not obvious to newcomers.

Finally, I structured the project for growth, keeping feature modules grouped by domain and services organized for cross cutting concerns. This matches the guidance in the architecture documents and helps contributors find the right place for new functionality. The file layout aligns with Expo Router conventions, which keeps navigation intuitive and avoids configuration overhead. I left room for analytics, notifications, and sync by centralizing adapters in services and exposing clean interfaces. Throughout the build, I focused on delivering a smooth inventory workflow that feels lightweight but reliable. The result is an app that can scale with real store needs confidently.
